use anyhow::{Context, Result};
use std::collections::BTreeSet;
use std::fs;

use crate::config::LignoreConfig;
use crate::template::TemplateIndex;

/// Generates gitignore file content from selected templates
pub fn generate_gitignore_content(
    selected: &[String],
    index: &TemplateIndex,
    config: &LignoreConfig,
) -> Result<String> {
    let mut output_lines = vec![
        "# Generated by lightignore".to_string(),
        format!("# Templates: {}", selected.join(", ")),
        String::new(),
    ];

    let mut seen_patterns = BTreeSet::new();

    for (idx, key) in selected.iter().enumerate() {
        if idx > 0 {
            output_lines.push(String::new());
        }
        output_lines.push(format!("# ===== {} =====", key));

        let content = load_template_content(key, index, config)?;
        process_template_lines(&content, &mut output_lines, &mut seen_patterns);
    }

    Ok(output_lines.join("\n"))
}

fn load_template_content(
    key: &str,
    index: &TemplateIndex,
    config: &LignoreConfig,
) -> Result<String> {
    if let Some(path) = index.get(key) {
        // Load from cache (official template)
        fs::read_to_string(path).with_context(|| format!("reading template {}", key))
    } else if let Some(custom_lines) = config.custom.get(key) {
        // Load from custom template (array of lines)
        Ok(custom_lines.join("\n"))
    } else {
        // Template not found, return empty content
        Ok(String::new())
    }
}

fn process_template_lines(
    content: &str,
    output_lines: &mut Vec<String>,
    seen_patterns: &mut BTreeSet<String>,
) {
    let lines: Vec<&str> = content.lines().collect();
    let mut i = 0;

    while i < lines.len() {
        let line = lines[i];
        let trimmed = line.trim();

        if trimmed.starts_with('#') {
            if should_include_comment(&lines, i, seen_patterns) {
                output_lines.push(line.to_string());
            }
        } else if trimmed.is_empty() {
            output_lines.push(line.to_string());
        } else {
            if seen_patterns.insert(trimmed.to_string()) {
                output_lines.push(line.to_string());
            }
        }
        i += 1;
    }
}

fn should_include_comment(
    lines: &[&str],
    comment_idx: usize,
    seen_patterns: &BTreeSet<String>,
) -> bool {
    // Look ahead to see if the next non-comment line is a pattern we've seen
    let mut j = comment_idx + 1;

    while j < lines.len() {
        let next_line = lines[j].trim();
        if next_line.starts_with('#') {
            j += 1;
            continue;
        }
        if !next_line.is_empty() {
            return !seen_patterns.contains(next_line);
        }
        break;
    }

    true
}

/// Ensures output directory exists
pub fn ensure_output_directory(output: &std::path::PathBuf) -> Result<()> {
    if let Some(parent) = output.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)
                .with_context(|| format!("creating output directory {}", parent.display()))?;
        }
    }
    Ok(())
}
